#!/usr/bin/env bash
# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch the error in case mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail
# Turn on traces, useful while debugging but commented out by default
# set -o xtrace

CF_API_ENDPOINT='api.london.cloud.service.gov.uk'
CF_ORG='dfe'
CF_SERVICE_NAME='teaching-vacancies'
CF_TARGET='review'
REPO="${CF_SERVICE_NAME}"
LIST_APP_GREP_PATTERNS=( "${CF_TARGET}-pr" )
DRY_RUN='true'
INTERACTIVE_LOGIN='false'
VERBOSE='false'

delete_associated_apps_services() {
  local pr="$1"
  if [[ -n "${pr}" ]]; then
    if [[ ${DRY_RUN} = 'true' ]] ; then
      echo_stdout_verbose "DRY RUN: Not executing cf delete commands"
    else
      echo "make changes here"
    fi
  fi
}

echo_stderr() {
  local message="${*}"
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: ERROR: ${message}" >&2
}

echo_stdout() {
  local message="${*}"
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: ${message}" >&1
}

echo_stdout_verbose() {
  local message="${*}"
  if [[ "${VERBOSE}" = 'true' ]]; then
    echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: VERBOSE: ${message}" >&1
  fi
}

main() {

  while getopts ":invp:" flag; do
    case "${flag}" in
      i)
        INTERACTIVE_LOGIN='true'
        echo_stdout "INTERACTIVE_LOGIN use command-line opt of ${INTERACTIVE_LOGIN}"
        ;;
      n)
        DRY_RUN='true'
        echo_stdout "DRY_RUN use command-line opt of ${DRY_RUN}"
        ;;
      p)
        OLDEST_PR=$OPTARG
        ;;
      v)
        VERBOSE='true'
        echo_stdout "VERBOSE use command-line opt of ${VERBOSE}"
        ;;
      \? )
        echo_stderr "Invalid Option: -${OPTARG}"
        exit 1
        ;;
      : )
        echo_stderr "Invalid Option: -${OPTARG} requires an argument"
        exit 1
        ;;
    esac
  done

  cf api "${CF_API_ENDPOINT}"
  if [[ "${INTERACTIVE_LOGIN}" = 'true' ]]; then
    cf login --sso
  else
    cf auth
  fi

  echo_stdout_verbose "Setting the target Org to ${CF_ORG} and Space to ${CF_SERVICE_NAME}-${CF_TARGET}"
  cf target -o "${CF_ORG}" -s "${CF_SERVICE_NAME}-${CF_TARGET}"

  for APP_GREP_PATTERN in "${LIST_APP_GREP_PATTERNS[@]}"; do
    if [[ -n "${OLDEST_PR}" ]]; then
      echo_stdout_verbose "Checking apps matching ${APP_GREP_PATTERN} with IDs lower than ${OLDEST_PR}"
      echo_stdout_verbose "Preparing to delete apps and services without checking GitHub open/closed status"
      PRS=$(cf apps | cut -d ' ' -f1 | grep "${APP_GREP_PATTERN}" | awk -F '-' -v oldest_pr="${OLDEST_PR}" '$NF < oldest_pr {print $NF}' | sort -n | uniq )
      for PR in ${PRS}; do
        echo_stdout_verbose "working with pr ${PR}"
        delete_associated_apps_services "${PR}"
      done
    else
      echo_stdout_verbose "Checking apps matching ${APP_GREP_PATTERN}"
      PRS=$(cf apps | cut -d ' ' -f1 | grep "${APP_GREP_PATTERN}" | awk -F '-' '{print $NF}' | sort -n | uniq )
      for PR in ${PRS}; do
        #PR="${CHECK/${APP_GREP_PATTERN}/}"
        #STATE=$(curl -u username:"${token}"  -s -X GET "https://api.github.com/repos/DFE-Digital/${REPO}/pulls/${PR}" | jq -r '.state ')
        #echo "${REPOS[$ITER]} Checking for PR - ${PR} ${STATE}"
        echo_stdout_verbose "${REPO} Checking for PR - ${PR} ${STATE}"
        if [[ "${STATE}" == "closed" ]]; then
          delete_associated_apps_services "${PR}"
        fi
      done
    fi
  done
}

main "$@"
